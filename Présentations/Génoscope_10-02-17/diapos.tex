\documentclass[t,12pt]{beamer}
\usepackage[T1]{fontenc} 
\usepackage[latin1]{inputenc}
\usepackage[british,frenchb]{babel}
\usepackage{pslatex}
\usetheme[secheader]{Boadilla}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{patterns}
\usetikzlibrary{decorations.pathreplacing}
\usepackage{multirow}

\def\sl{{\par\leavevmode\par}}

\title{Correction et assemblage de reads longs}
\date{\today}
\author[Pierre Morisse]{Pierre Morisse}
%
\begin{document}

	\AtBeginSection{
		\begin{frame}
			\tableofcontents[currentsection]
		\end{frame}
	}
	
	\frame{\titlepage}
	
	\begin{frame}[c]{Plan de la présentation}
		\tableofcontents[hideallsubsections]
	\end{frame}
	
	\section{Première approche de correction}
	
	\begin{frame}[c]{Idée}
		\begin{itemize}
			\item Comme NaS, produire des \emph{reads} longs synthétiques à partir d'un assemblage de \emph{reads} courts \sl
			
			\item Se débarrasser de l'étape d'alignement des \emph{reads} courts entre eux \sl
			
			\item Ne déduire des informations qu'à partir de l'alignement des \emph{reads} courts sur les \emph{reads} longs \sl
		\end{itemize}				
	\end{frame}
	
	\begin{frame}[c]{Fonctionnement}
		Nous présentons la méthode pour le traitement d'un \emph{read} long \sl
		
		\onslide<2->{
		\begin{block}{Principe}
				Alignement des \emph{reads} courts sur le \emph{read} long \emph{template}, en se
				fixant un seuil $lmin$, pour récupérer les \emph{reads} : \sl
				\begin{itemize}
					\onslide<3->{
					\item Totalement alignés, et servant de \emph{seeds}
					}
					\onslide<4->{
					\item Avec un préfixe de longueur $\geqslant lmin$ aligné
					}
					\onslide<5->{
					\item Avec un suffixe de longueur $\geqslant lmin$ aligné
					}
				\end{itemize}
		\end{block}
		}
	\end{frame}
	
	\begin{frame}[c]{Fonctionnement}
		\begin{block}{Deux étapes d'extensions :}
				\begin{enumerate}
					\onslide<2->{
					\item Recrutement de \emph{reads} partiellement alignés, similaires aux \emph{seeds} \sl
					\begin{center}
						\resizebox{0.4\textwidth}{!}{
							\begin{tikzpicture}
								%SEED
								\draw [|-|] (1,1) -- (4,1);
								\node [right] at (4,1) {seed};
								%SUFFS
								\draw [red] [|-|] (-1.5,0) -- (-0.5,0);
								\draw [red] [|-|] (-0.5,0) -- (1.5,0);
								\node [left] at (-1.5,0) {\textcolor{red}{$r_1$}};
								\draw [red] [<->] (-0.5,-0.5) -- (1.5,-0.5);
								\node [below] at (0.5,-0.5) {\textcolor{red}{suffixe aligné}};
								%PREF
								\draw [green] [|-|] (2.5,0) -- (4,0);
								\draw [green] [|-|] (4,0) -- (5.5,0);
								\node [right] at (5.5,0) {\textcolor{green}{$r_2$}};
								\draw [green] [<->] (2.5,-0.5) -- (4,-0.5);
								\node [below] at (3.225,-0.5) {\textcolor{green}{préfixe aligné}};
								%LMINS
								\draw [<->] (1,0.5) -- (2,0.5);
								\node [above] at (1.5,0.5) {$lmin$};
								\draw [<->] (3,0.5) -- (4,0.5);
								\node [above] at (3.5,0.5) {$lmin$};
							\end{tikzpicture}
						}
					\end{center}
					}
					
					\onslide<3->{
					\item Recrutement de nouveaux \emph{reads} partiellement alignés, sans relation de similarité,
					en se fixant un nouveau seuil $lmax$ \sl
					\begin{center}
						\resizebox{0.6\textwidth}{!}{
							\begin{tikzpicture}
								%SEED
								\draw [|-|] (0,1) -- (7,1);
								\node [right] at (7,1) {contig};
								
								%LMAX
								\draw [<->] (0,1.5) -- (0.5,1.5);
								\node [above] at (0.25,1.5) {$lmax$};
								\draw [<->] (6.5,1.5) -- (7,1.5);
								\node [above] at (6.75,1.5) {$lmax$};
								
								%SUFF
								\draw [red] [|-|] (-2,0.5) -- (-0.3,0.5);
								\draw [red] [|-|] (-0.3,0.5) -- (1,0.5);
								\node [left] at (-2,0.5) {\textcolor{red}{$s_1$}};
								
								%PREF								
								\draw [green] [|-|] (6.85,0.5) -- (8.25,0.5);
								\draw [green] [|-|] (8.25,0.5) -- (9.85,0.5);
								\node [right] at (9.85,0.5) {\textcolor{green}{$p_1$}};
							\end{tikzpicture}
						}
					\end{center}
					}
				\end{enumerate}
		\end{block}
	\end{frame}
	
	\begin{frame}[c]{Exemple}
		\resizebox{1\textwidth}{!}{
			\begin{tikzpicture}
				% Etape 1
				% Template
				\fill [pattern=north west lines, pattern color=blue] (-4,1.9) rectangle (-1,2.1);
				\draw [-, blue] (-1,2) -- (0.5,2);
				\fill [pattern=north west lines, pattern color=blue] (0.5,1.9) rectangle (1,2.1);
				\draw [-, blue] (1,2) -- (5,2);
				\fill [pattern=north west lines, pattern color=blue] (5,1.9) rectangle (6.3,2.1);
				\draw [-, blue] (6.3,2) -- (7.3,2);
				\fill [pattern=north west lines, pattern color=blue] (7.3,1.9) rectangle (14,2.1);
				\node [right] at (14,2) {\textcolor{blue}{\footnotesize \emph{template}}};
				
				% Seed
				\onslide<2->{
					\fill[fill=black] (2,0.8) rectangle (5,1);
					\node [right] at (5,1) {\footnotesize seed};
				}
				
				% Read avec suffixe aligné
				\onslide<3->{
					\draw [green] [|-] (0,0) -- (1,0);
					\fill [green] (1,-0.1) rectangle (3,0.1);
				}
				
				% Read avec préfixe aligné
				\onslide<4->{
					\fill [green] (3.5,-0.1) rectangle (5,0.1);
					\draw [green] [-|] (5,0) -- (6.5,0);
				}
				
				% Lmin
				\onslide<3->{
					\draw [<->] (2,0.6) -- (3,0.6);
					\node [below] at (2.5,0.6) {\footnotesize $lmin$};
				}
				\onslide<4->{
					\draw [<->] (4,0.6) -- (5,0.6);
					\node [below] at (4.5,0.6) {\footnotesize $lmin$};
				}
				
				% Flèche
				\onslide<5->{
					\draw [-triangle 45] (3.25,-1) -- (3.25,-2.5);
				}
				
				% Contig obtenu
				\onslide<5->{
					\draw [green] [|-] (0,-3.5) -- (1,-3.5);
					\fill [green] (1,-3.4) rectangle (2,-3.6);
					\fill[fill=black] (2,-3.4) rectangle (5,-3.6);
					\draw [green] [-|] (5,-3.5) -- (6.5,-3.5);
					\node [right] at (6.5,-3.5) {\footnotesize contig obtenu};
				}
				
				% Accolade
				\onslide<6->{
					\draw [decorate,decoration={brace, amplitude=10pt, mirror}]
					(-1,1) -- (-1,-3.6) node [black, midway, xshift=-2cm] 
					{\footnotesize \'Etape 1};
				}
				
				
				% Etape 2
				% Read avec suffixe aligné
				\onslide<7->{
					\draw [green] [|-] (-2.5,-4.5) -- (-1,-4.5);
					\fill [green] (-1,-4.4) rectangle (0.5,-4.6);
				}
				
				% Read avec préfixe aligné
				\onslide<8->{
					\fill [green] (6.3,-4.4) rectangle (7.3,-4.6);
					\draw [green] [-|] (7.3,-4.5) -- (9.3,-4.5);
				}
				
				% Lmax
				\onslide<7->{
					\draw [<->] (0,-4.1) -- (0.5,-4.1);
					\node [above] at (0.25,-4.1) {\footnotesize $lmax$};
				}
				\onslide<8->{
					\draw [<->] (6,-4.1) -- (6.5,-4.1);
					\node [above] at (6.25,-4.1) {\footnotesize $lmax$};
				}
				
				% Lmin
				\onslide<7->{
					\draw [<->] (-0.5,-4.9) -- (0.5,-4.9);
					\node [below] at (0,-4.85) {\footnotesize $lmin$};
				}
				\onslide<8->{
					\draw [<->] (6.3,-4.9) -- (7.3,-4.9);
					\node [below] at (6.8,-4.85) {\footnotesize $lmin$};
				}
				
				% Flèche
				\onslide<9->{
					\draw [-triangle 45] (3.4,-6) -- (3.4,-7.5);
				}
				
				% Contig obtenu
				\onslide<9->{
					\draw [green] [|-] (-2.5,-8.5) -- (-1,-8.5);
					\fill [green] (-1,-8.4) rectangle (0,-8.6);
					\draw [green] [-] (0,-8.5) -- (1,-8.5);
					\fill [green] (1,-8.4) rectangle (2,-8.6);
					\fill[fill=black] (2,-8.4) rectangle (5,-8.6);
					\draw [green] [-] (5,-8.5) -- (6.5,-8.5);
					\fill [green] (6.5,-8.4) rectangle (7.3,-8.6);
					\draw [green] [-|] (7.3,-8.5) -- (9.3,-8.5);
					\node [right] at (9.3,-8.5) {\footnotesize contig obtenu};
				}
				
				% Accolade
				\onslide<10->{
					\draw [decorate,decoration={brace, amplitude=10pt}]
					(14,-3.4) -- (14,-8.5) node [black, midway, xshift=2cm] 
					{\footnotesize \'Etape 2};
				}
			\end{tikzpicture}
		}
	\end{frame}
	
	\begin{frame}[c]{Résultats et conclusions}
		Résultats après application de notre méthode sur un ensemble de \emph{reads} longs ADP1, avec $lmin = 100$ et $lmax = 10$ : \sl
		
		\onslide<2->{
		\resizebox{\textwidth}{!}{
			\begin{tabular}{|c|c|c|c|c|c|c|c|}
				\hline
				\emph{Reads} & Longueur moyenne & Précision moyenne & Contigs / \emph{read} & Longueur moyenne & Précision moyenne 
				& Template couvert & Temps \\
				\hline
				1D & 2 052 & 56,5\% & 2,296 & 645 & 88,636\% & 72,17\% & 19min52 \\
				\hline
				2D & 10 033 & 74,5\% & 2,732 & 2 421 & 88,186\% & 65,93\% & 14h06min \\
				\hline
			\end{tabular}
		} \sl
		}
		
		\begin{itemize}
			\onslide<3->{
			\item Temps de traitement : moins de 10 secondes pour un \emph{read} long \sl
			}
			\onslide<4->{
			\item Encore un taux d'erreurs de 12 \% \sl
			}
			\onslide<5->{
			\item Obtention de plusieurs contigs pour chaque \emph{read} long, et faible taux de couverture de ces derniers \sl
			}
			\onslide<6->{
			\item Modifier les paramètres ne permet pas d'obtenir de meilleurs résultats
			}
		\end{itemize}		
	\end{frame}
	
	\section{Scaffolding avec reads longs}
	
	\begin{frame}[c]{Idée}
		\begin{itemize}
			\item Obtenir des contigs à partir d'un assemblage de \emph{reads} courts \sl
			
			\onslide<2->{
			\item Aligner les \emph{reads} longs sur ces contigs avec BLASR pour trouver des alignements locaux \sl
			}			
			
			\onslide<3->{
			\item Relier et ordonner les contigs grâce aux \emph{reads} longs s'alignant sur plusieurs contigs \sl
			}
						
			\onslide<4->{			
			\item Combler les gaps entre deux contigs liés par un consensus des bases des \emph{reads} longs
			}
		\end{itemize}
	\end{frame}
	
	\begin{frame}[c]{Exemple}
		\resizebox{\textwidth}{!}{
		\begin{tikzpicture}
			\draw [|-|] (-10,1) -- (-3,1);
			\node at (-11,1) {contig$_1$};
			\draw [|-|] (2,1) -- (7,1);
			\node at (8,1) {contig$_2$};
			\onslide<2->{
			\draw [|-|, red] (-5,0) -- (5,0);
			\node at (6,0) {\textcolor{red}{read long$_1$}};
			}
			\onslide<3->{
			\draw [|-|, red] (-7,-1) -- (4,-1);
			\node at (5,-1) {\textcolor{red}{read long$_2$}};
			}
			\onslide<4->{
			\node at (-0.5,-2) {\textcolor{red}{\vdots}};
			}
			\onslide<5->{			
			\draw [|-|, red] (-4,-3) -- (3,-3);
			\node at (4,-3) {\textcolor{red}{read long$_n$}};
			}
			\onslide<6->{
			\draw [dashed, red] (-3,1) -- (-3,-3);
			\draw [dashed, red] (2,1) -- (2,-3);
			}
			\onslide<7->{
			\draw [decorate,decoration={brace, amplitude=10pt, mirror}]
					(-3,-3.5) -- (2,-3.5) node [black, midway, yshift=-1cm] 
					{\footnotesize Consensus};
			}
			
			\onslide<8->{			
			\draw [-triangle 45] (-0.5,-5) -- (-0.5,-6);										
			\draw [|-|] (-10,-7) -- (-3,-7);
			\draw [-, red] (-3,-7) -- (2,-7);
			\draw [|-|] (2,-7) -- (7,-7);
			\node at (8.5,-7) {scaffold obtenu};
			}
		\end{tikzpicture}
		}
	\end{frame}
	
	\begin{frame}[c]{Remarques et conclusion}
		\begin{itemize}
			\onslide<1->{
			\item Méthode déjà existante : SSPACE-LongRead permet déjà de scaffolder des contigs à l'aide de \emph{reads} longs,
				  mais comble les gaps avec des N plutôt qu'avec un consensus des bases des \emph{reads} longs \sl
			}
							  
			\onslide<2->{			
			\item PBJelly permet également de scaffolder les contigs, mais quant à lui, comble également les gaps avec les bases des
				  \emph{reads} longs \sl
			}
			
			\onslide<3->{
			\item Inutile de développer davantage cette idée
			}
		\end{itemize}
	\end{frame}
	
	\section{Comparaison de k-mers reads longs / contigs reads courts}
	
	\begin{frame}[c]{Idée}
		\begin{itemize}
			\item Récupérer les $k$-mers apparaissant dans les \emph{reads} longs mais pas dans les contigs de \emph{reads} courts \sl
			
			\onslide<2->{
			\item Assembler les $k$-mers récupérés $\Rightarrow$ Obtention de nouveau contigs \sl
			}
			
			\onslide<3->{
			\item Utiliser ces nouveaux contigs pour couvrir les zones du génome de référence non couvertes par les contigs de \emph{reads} courts \sl
			}
			
			\onslide<4->{
			\item Permettre un assemblage moins fragmenté en assemblant les contigs de \emph{reads} courts et les contigs de \emph{reads} longs
			}
		\end{itemize}
	\end{frame}
	
	\begin{frame}[c]{Tests et résultats}
		Avec un ensemble de \emph{reads} de ADP1 : \sl
		
		\resizebox{\textwidth}{!}{
		\begin{tabular}{|c|c|c|}
			\hline
			Taille d'un $k$-mer & Nombre de $k$-mers & Nombre de $k$-mers dans les contigs \\
			\hline
			64 & 375 999 371 & 380 967 \\
			\hline
			32 & 335 836 269 & 2 942 135 \\
			\hline
			16 & 322 493 916 & 6 197 488 \\
			\hline
			8 & 65 376 & 65 309 \\
			\hline
		\end{tabular}
		} \sl \sl
		
		\onslide<2->{
		Peu concluant, hormis pour les 8-mers, mais ceux-ci n'apportent pas d'information pertinente \sl
		}		
		
		\onslide<3->{
		$\Rightarrow$ Plus intéressant rechercher des $k$-mers espacés ?
		}
	\end{frame}
	
	\begin{frame}[c]{$k$-mers espacés}
		\begin{block}{Définition}
			Ici, on appelle $k$-mer espacé un $k$-mer dans lequel on autorise un gap d'une certaine longueur au centre.
		\end{block} \sl
		
		\onslide<2->{
		\begin{exampleblock}{Exemple}
			Par exemple, le 8-mer GATCTTAC, si on autorise un gap de longueur 2, deviendra le "8"-mer-2-espacé suivant : GATC**TTAC,
			où les * désignent des positions jokers (match ou mismatch autorisé)
		\end{exampleblock} \sl
		}
		
		\onslide<3->{
		On utilise cette définition des $k$-mers espacés plutôt que la définition classique afin de pouvoir prendre en compte les erreurs
		d'indels plutôt que les erreurs de substitution
		}
	\end{frame}
	
	\begin{frame}[c]{Tests et résultats}
		Résultats, sur le jeu de données précédent, en autorisant un gap de longueur comprise entre 0 et 10 : \sl
		
		\resizebox{\textwidth}{!}{
		\begin{tabular}{|c|c|c|}
			\hline
			Taille d'un $k$-mer & Nombre de $k$-mers & Nombre de $k$-mers dans les contigs \\
			\hline
			64 & 375 999 371 & 425 155 \\
			\hline
			32 & 335 836 269 & 3 859 742 \\
			\hline
			16 & 322 493 916 & 16 036 610 \\
			\hline
		\end{tabular}
		} \sl \sl
		
		\onslide<2->{
		$\Rightarrow$ La comparaison n'est toujours pas concluante, même avec des $k$-mers espacés
		}
	\end{frame}
	
	\begin{frame}[c]{Remarques}
		\begin{itemize}
			\onslide<1->{
			\item Trimmer les extrémités des \emph{reads} longs ne permet pas d'obtenir de meilleurs résultats
				  $\Rightarrow$ Contrairement aux \emph{reads} courts, les erreurs ne se trouvent pas majoritairement
				  aux extrémités, mais partout dans les \emph{reads} longs \sl
			}
			
			\onslide<2->{
			\item Comparer les $k$-mers des \emph{reads} longs directement avec les $k$-mers des \emph{reads} courts
				  plutôt qu'avec les contigs ne permet pas non plus d'obtenir de meilleurs résultats \sl
			}
			
			\onslide<3->{
			\item Approche non concluante \sl
			}
			
			\onslide<4->{
			\item Autoriser plus de gaps dans les $k$-mers, et non un seul au milieu, pourrait potentiellement amener
				  de meilleurs résultats => Besoin d'un algorithme pour construire une table des suffixes espacée
			}
		\end{itemize}
	\end{frame}
	
	\section{Approche de correction prometteuse}
	
	\begin{frame}[c]{Principe}	
		5 étapes : \sl
			
		\begin{enumerate}
			\onslide<2->{
			\item Correction des \emph{reads} courts (avec Quorum) \sl		
			}
			
			\onslide<3->{
			\item Alignement des \emph{reads} courts sur le \emph{read} long, afin de trouver des \emph{seeds} (avec BLASR)  \sl
			}
			
			\onslide<4->{
			\item Fusion des \emph{seeds} se chevauchant sur une longueur assez importante \sl
			}
			
			\onslide<5->{
			\item Relier les \emph{seeds} en les étendant à l'aide de chevauchements parfaits avec les $k$-mers des \emph{reads} courts \sl
			}
			
			\onslide<6->{
			\item Extension du \emph{read} long sythétique obtenu, à gauche (resp. à droite) du \emph{seed} le plus à gauche (resp. à droite)
			}
		\end{enumerate}				
	\end{frame}
	
	\begin{frame}[c]{Outil utilisé : PgSA}
		\onslide<1->{
		PgSA (Pseudogenome Suffix Array) permet d'indexer un ensemble de \emph{reads}, et de répondre aux 7 requêtes suivantes,
		pour une chaîne $f$ donnée :
		}
		
		
		\begin{enumerate}
			\onslide<2->{
			\item Dans quels \emph{reads} $f$ apparaît ?
			}
			\onslide<3->{
			\item Dans combien de \emph{reads} $f$ apparaît ?
			}
			\onslide<4->{
			\item Quelles sont les occurrences de $f$ ?
			}
			\onslide<5->{
			\item Quel est le nombre d'occurrences de $f$ ?
			}
			\onslide<6->{
			\item Dans quels \emph{reads} $f$ n'apparaît qu'une fois ?
			}
			\onslide<7->{
			\item Dans combien de \emph{reads} $f$ n'apparaît qu'une fois ?
			}
			\onslide<8->{
			\item Quelles sont les occurrences de $f$ dans les \emph{reads} où $f$ n'apparaît qu'une fois ?
			}
		\end{enumerate}
		
		\onslide<9->{
		Parmi ces requêtes, la 3ème va nous permettre de trouver des chevauchements parfaits entre les $k$-mers
		}
	\end{frame}
	
	\begin{frame}[c]{Outil utilisé : PgSA}
		D'autres structures (Gk-Arrays, Compressed Gk-Arrays) permettent le traitement des ces requêtes, mais la longueur $k$ de $f$ doit être
		fixée à la compilation, alors que PgSA permet de traiter les requêtes pour des valeurs de $k$ variables. \sl
		
		\onslide<2->{
		=> Permet de chercher des chevauchements de longueur $k-2$ si aucun chevauchement de longueur $k-1$ n'a été trouvé, sans avoir besoin de recalculer
		l'index
		}
	\end{frame}		
	
	\begin{frame}[c]{Étape 4}
		Indexation de l'ensemble des $k$-mers des \emph{reads} courts (et de leurs reverse-complement) avec PgSA, et boucle sur la requête 3 afin de trouver 
		des chevauchements parfaits de $k$-mers permettant de relier les \emph{seeds} entre eux \sl
		
			\onslide<2->{
			\begin{center}
			\resizebox{0.75\textwidth}{!}{
				\begin{tikzpicture}
					%TEMPLATE
					\draw [fill,blue] (-6,1.05) rectangle (5.5,0.95);
					\node at (6,1) {\textbf{\textcolor{blue}{.  .  .  .}}};
					\draw [fill=blue] [-|] (6.5,1.05) rectangle (7.5,0.95);
					\node [right] at (8,1) {\textcolor{blue}{\emph{read} long}};
					%SEEDS					
					\onslide<1-9>{
					\draw [fill=black] (-5.5,0.05) rectangle (-2.5,-0.05);
					}					
					\onslide<3-5>{
					\draw [fill=red] (-3.5,0.05) rectangle (-2.5,-0.05);
					}
					\onslide<5-8>{
					\draw [fill=green] (-2.5,0.05) rectangle (-2.25,-0.05);
					}
					\onslide<6-8>{
					\draw [fill=green] (-3.25,0.05) rectangle (-2.25,-0.05);
					}
					\onslide<8>{
					\draw [fill=orange] (-2.25,0.05) rectangle (-2,-0.05);
					}
					\onslide<9>{
					\draw [fill=orange] (-3,0.05) rectangle (-2,-0.05);
					}
					\draw [fill=black] (2,0.05) rectangle (5,-0.05);
					%K-MERS
					\onslide<4>{
					\draw [fill=green] (-3.25,-0.1) rectangle (-2.25,-0.2);
					}
					\onslide<7>{
					\draw [fill=orange] (-3,-0.1) rectangle (-2,-0.2);
					}
					\onslide<10-12>{
					\draw [fill=black] (-5.5,0.1) rectangle (2.75,0.2);
					}
					\onslide<11-12>{
					\draw [fill=yellow] (1.75,0.1) rectangle (2.75,0.2);
					}
					\onslide<12>{
					\draw [fill=pink] (2,0.05) rectangle (3,-0.05);
					}
					\onslide<13->{
					\draw [fill=black] (-5.5,0.05) rectangle (3,-0.05);
					}
				\end{tikzpicture}
			}
			\end{center} \sl
			}
	\end{frame}
	
	\begin{frame}[c]{Remarques}
		\begin{itemize}
			\item Il est possible qu'un $k$-mer chevauche parfaitement plusieurs $k$-mers $\Rightarrow$ Exploration de toutes les
				  extensions possibles avec du backtracking \sl
			
			\onslide<2-> {
			\item Certains \emph{seeds} peuvent être impossibles à relier $\Rightarrow$ Production d'un \emph{read} long 
				  synthétique fragmenté en plusieurs parties \sl
			}
			
			\begin{center}
			\resizebox{0.75\textwidth}{!}{
				\begin{tikzpicture}
					%TEMPLATE
					\onslide<3->{
					\draw [fill=blue] [-] (-12,1.05) rectangle (9,0.95);
					\node [right] at (9,1) {\textcolor{blue}{\emph{read} long}};
					}
					%SEEDS
					\onslide<4->{
					\draw [fill=black] (-9,0.05) rectangle (-6,-0.05);
					\node [right] at (-6,0) {seed$_1$};
					}
					\onslide<5->{
					\draw [fill=black] (3,0.05) rectangle (6,-0.05);
					\node [right] at (6,0) {seed$_2$};
					}
					
					%TEMPLATE
					\onslide<6->{
					\draw [fill=red] (-12,-2.05) rectangle (-10.5,-1.95);
					\node at (-10,-2) {\textbf{\textcolor{red}{. . . .}}};
					\draw [fill=red] (-9.5,-2.05) rectangle (6,-1.95);
					\node at (6.5,-2) {\textbf{\textcolor{red}{. . . .}}};
					\draw [fill=red] (7,-2.05) rectangle (9,-1.95);
					\node [right] at (9,-2) {\textcolor{red}{génome de référence}};
					}
					%SEEDS
					\onslide<7->{					
					\draw [fill=black] (-8,-3.05) rectangle (-5,-2.95);
					\node [right] at (-5,-3) {seed$_2$};
					}
					\onslide<8->{
					\draw [fill=black] (2.5,-3.05) rectangle (5.5,-2.95);
					\node [right] at (5.5,-3) {seed$_1$};
					}	
				\end{tikzpicture}
			}
			\end{center}
			
			\onslide<9->{
			\item Lorsqu'un \emph{read} long ne possède qu'un \emph{seed}, on se contente alors d'étendre celui-ci à gauche et à droite
			}
		\end{itemize}
	\end{frame}
	
	\begin{frame}[c]{Étape 5}
		Le \emph{seed} le plus à gauche ne s'aligne pas toujours en position 0 sur le \emph{read} long, et de même, le \emph{seed} 
		le plus à droite n'atteint pas toujours l'extrémité droite du \emph{read} long. \sl
		
		\onslide<2->{
		$\Rightarrow$ Une fois tous les \emph{seeds} reliés et le \emph{read} long synthétique produit, on étend, 
		à l'aide de chevauchements parfaits de $k$-mers, son extrémité gauche et son extrémité droite, jusqu'à atteindre 
		les extrémités du \emph{read} long initial, ou une ambiguïté (extension possible à l'aide de plus d'un k-mer)
		}
	\end{frame}
	
	\begin{frame}[c]{Étape 5, Cas 1 : Pas d'ambiguïté}
			\begin{center}
			\resizebox{0.75\textwidth}{!}{
				\begin{tikzpicture}
					%TEMPLATE
					\draw [fill=blue] [-] (-12,1.05) rectangle (9,0.95);
					\node [right] at (9,1) {\textcolor{blue}{\emph{read} long}};
					%LR CORRIGÉ
					\draw [fill=black] [-] (-9,-0.95) rectangle (6,-1.05);
					\onslide<2-4>{
					\draw [fill=red] [-] (5,-0.95) rectangle (6,-1.05);
					}
					\node [right] at (-2,-2) {\emph{read} long synthétique};
					%EX
					\onslide<3>{
					\draw [fill=green] (5.25,-1.15) rectangle (6.25,-1.25);
					}
					\onslide<4-5>{
					\draw [fill=green] (6,-0.95) rectangle (6.25,-1.05);
					}
					\onslide<5-7>{
					\draw [fill=green] (5.25,-0.95) rectangle (6.25,-1.05);
					}
					\onslide<6>{
					\draw [fill=orange] (5.5,-1.15) rectangle (6.50,-1.25);
					}
					\onslide<7-8>{
					\draw [fill=orange] (6.25,-0.95) rectangle (6.50,-1.05);
					}
					\onslide<8>{
					\draw [fill=orange] (5.50,-0.95) rectangle (6.50,-1.05);
					}
					\onslide<9->{
					\draw [fill=black] [-] (-9,-0.95) rectangle (8.75,-1.05);
					}
					\onslide<10-12>{
					\draw [fill=yellow] [-] (7.75,-0.95) rectangle (8.75,-1.05);
					}
					\onslide<11>{
					\draw [fill=pink] (8,-1.15) rectangle (9,-1.25);
					}
					\onslide<12-13>{
					\draw [fill=pink] (8.75,-0.95) rectangle (9,-1.05);
					}
					\onslide<13->{
					\draw [fill=pink] (8,-0.95) rectangle (9,-1.05);
					}				
					%TRAIT
					\onslide<14->{
					\draw [green, dashed] (9,1.05) -- (9,-1.25);
					}
					\onslide<15->{
					\draw [fill=black] [-] (-9,-0.95) rectangle (9,-1.05);
					}
				\end{tikzpicture}
			} 
			\end{center}
	\end{frame}
	
	\begin{frame}[c]{Étape 5, Cas 2 : Présence d'une ambiguïté}
			\begin{center}
			\resizebox{0.75\textwidth}{!}{
				\begin{tikzpicture}
					%TEMPLATE
					\draw [fill=blue] [-] (-12,1.05) rectangle (9,0.95);
					\node [right] at (9,1) {\textcolor{blue}{\emph{read} long}};
					%LR CORRIGÉ
					\draw [fill=black] [-] (-9,-0.95) rectangle (6,-1.05);
					\onslide<2-4>{
					\draw [fill=red] [-] (-9,-0.95) rectangle (-8,-1.05);
					}
					\node [right] at (-2,-2) {\emph{read} long synthétique};
					%EXT GAUCHE
					\onslide<3>{
					\draw [fill=green] (-9.25,-1.15) rectangle (-8.25,-1.25);
					}
					\onslide<4-5>{
					\draw [fill=green] (-9.25,-0.95) rectangle (-9,-1.05);
					}
					\onslide<5-7>{
					\draw [fill=green] (-9.25,-0.95) rectangle (-8.25,-1.05);
					}
					\onslide<6>{
					\draw [fill=orange] (-9.50,-1.15) rectangle (-8.50,-1.25);
					}
					\onslide<7-8>{
					\draw [fill=orange] (-9.50,-0.95) rectangle (-9.25,-1.05);
					}
					\onslide<8-9>{
					\draw [fill=orange] (-9.50,-0.95) rectangle (-8.50,-1.05);
					}
					\onslide<9>{
					\draw [fill=blue] (-9.75,-1.15) rectangle (-8.75,-1.25);
					\draw [fill=pink] (-9.75,-0.85) rectangle (-8.75,-0.75);
					}
					\onslide<10>{
					\draw [fill=black] [-] (-9.5,-0.95) rectangle (6,-1.05);
					}
				\end{tikzpicture}
			} 
			\end{center}
	\end{frame}
	
	\begin{frame}[c]{Résultats et comparaison avec NaS : Alignement}		
	
			Sur les 6 ensembles de \emph{reads} longs ADP1 disponibles sur le site du Génoscope :
			
			\begin{table}
			\resizebox{1\textwidth}{!}{
			\begin{tabular}{|c|c|c|c|c|c|}
				\hline
				& \textbf{Nombre de reads} & \textbf{Longueur moyenne} & \textbf{Taille totale} & \textbf{Identité moyenne} \\
				\hline
				\textbf{\emph{reads} longs bruts} & 70 314 & 	2 530 & 177 869 033 & 3,84 \% \\
				\hline
				\textbf{NaS (fast)} & 8 219 & 4 514 & 37 099 564 & 99,92 \% \\
				\hline
				\textbf{NaS (sensitive)} & 12 053 & 6 338 & 76 388 104 & 99,89 \% \\
				\hline
				\textbf{Nous} & 7 425 (dont 249 fragmentés) & 10 250 & 78 739 767 & 99,57 \% \\
				\hline
			\end{tabular}
			}
			\caption{Sur l'ensemble des \emph{reads} 1D}
			\end{table}
		
			\onslide<2->{
			\begin{table}
			\resizebox{1\textwidth}{!}{
			\begin{tabular}{|c|c|c|c|c|c|}
				\hline
				& \textbf{Nombre de reads} & \textbf{Longueur moyenne} & \textbf{Taille totale} & \textbf{Identité moyenne} \\
				\hline
				\textbf{\emph{reads} longs brutss} & 18 697 & 10 884 & 203 496 742 & 37,07 \% \\
				\hline
				\textbf{NaS (fast)} & 15 844 & 11 084 & 175 607 625 & 99,78 \% \\
				\hline
				\textbf{NaS (sensitive)} & 16 439 & 11 871 & 195 138 674 & 99,79 \% \\
				\hline
				\textbf{Nous} & 15 575 (dont 984 fragmentés) & 10 562 & 178 222 404 & 99,54 \% \\
				\hline
			\end{tabular}
			}
			\caption{Sur l'ensemble des \emph{reads} 2D}
			\end{table}
			}
	\end{frame}
	
	\begin{frame}[c]{Résultats et comparaison avec NaS : Assemblage}		
	
			Avec les 2 ensembles de \emph{reads} longs 1D et 2D préalablement décrits et corrigés :
			
			\begin{table}
			\resizebox{\textwidth}{!}{
			\begin{tabular}{|c|c|c|c|c|c|}
			\hline
			\textbf{Outil} & \textbf{Nombre de reads} & \textbf{Nombre de contigs} & \textbf{Couverture du génome} 	
			& \textbf{Identité} \\
			\hline
			\textbf{NaS (fast)} & 24 063 & 1 & 100 \% & 99,98 \% \\
			\textbf{NaS (sensitive)} & 28 492 & 1 & 100 \% & 99,99 \% \\
			\textbf{Notre méthode} & 23 000 (1 233 fragmentés) & 1 & 99,95 \% & 99,97 \% \\
			\hline
			\end{tabular}
			}
			\caption{Résultats d'assemblage \label{tabres3}}
			\end{table}
			
	\end{frame}
	
	\begin{frame}[c]{Résultats et comparaison avec NaS : Temps et espace}	
		\onslide<2->{
		NaS : 72h avec 8 processus, et production de 100Go de fichiers temporaires \sl
		}
		
		\onslide<3->{
		Nous : 35h avec 1 processus, et aucune production de fichiers temporaires, hormis le fichier d'alignement des \emph{reads} courts
		sur les \emph{reads} longs \sl
		}
	\end{frame}
	
	\begin{frame}[c]{Perspectives}
		\begin{itemize}			
			\onslide<1->{
			\item Paralléliser la correction pour accélérer le temps de traitement \sl
			}
			\onslide<2->{
			\item Tester la méthode sur les autres jeux de données disponibles sur le site du Génoscope \sl
			}
			\onslide<3->{
			\item Ajuster les paramètres afin d'obtenir de meilleurs résultats \sl
			}
		\end{itemize}
	\end{frame}
	
	\section{Mapping de reads longs sur DBG}
	
	\begin{frame}[c]{Méthodes existantes}
		\begin{itemize}
			\item LoRDEC (2014, Hybride, DBG de \emph{reads} courts) \sl
			
			\item Jabba (2016, Hybride, DBG de \emph{reads} courts) \sl
			
			\item LoRMA (2016, Uniquement \emph{reads} longs, DBG de \emph{reads} longs) \sl
			\end{itemize}
	\end{frame}
	
\end{document}